
#rabbitmq 与 kafka 对比

    rabbitmq       
    1.RabbitMQ的消息应当尽可能的小，并且只用来处理实时且要高可靠性的消息。
    2.消费者和生产者的能力尽量对等，否则消息堆积会严重影响RabbitMQ的性能。
    3.集群部署，使用热备，保证消息的可靠性。
    
    kafka
    1.应当有一个非常好的运维监控系统，不单单要监控Kafka本身，还要监控Zookeeper。(kafka强烈的依赖于zookeeper,如果zookeeper挂掉了，那么Kafka也不行了)
    2.对消息顺序不依赖，且不是那么实时的系统。
    3.对消息丢失并不那么敏感的系统。
    4.从 A 到 B 的流传输，无需复杂的路由，最大吞吐量可达每秒 100k 以上。

# RPC和MQ各自适合的应用场景

    1.RPC比较适合- 客户端调用哪个服务器比较明确
    调用需要立即得到返回结果 
    架构简单 在一个由多个微服务构成的大系统中，某些关键服务间的调用应当在较短的时间内返回，而且各个微服务的专业化程度较高，同一个请求的关注者只有一个。这个时候就应该用RPC。 比如在一个ERP系统中，有一个管理仓储的微服务，以及一个负责订单的微服务。新建订单时需要查知当前的存货是否充足，如果不充足就通知用户；提交订单时预订指定数量的货物，如果此时货物不错，也要终止订单的提交，并通知用户。显然在这种场景下是不允许较大的延迟，否则会影响用户体验。所以应该使用RPC，及时返回仓储情况。

    2.MQ比较适合
    消息的发送者和消费者需要解耦的情况 
    发送者并不明确也不关心谁是消费者 
    各个消费者可以从不同的角度入手处理消息 
    消费者的处理结果也不返回给发送者 
    消息的发送和处理是异步的 
    消息的关注者不止一个 
    在一个由多个微服务构成的大系统中，会有一些非关键服务，用来执行一些不需要立刻得到结果的计算。而且它们的计算结果并不会返回给消息的发送者。这个时候就应该使用MQ。

# RabbitMQ 
    5672  客户端代码 连接端口
    15672 web 页面管理端口 
    
    
#公平转发
    
    目前消息转发机制是平均分配，这样就有可能会出现俩个消费者，奇数的任务很耗时，偶数的任何工作量很小，
    造成的原因就是近当消息到达队列进行转发消息。并不在乎有多少任务消费者并未传递一个应答给RabbitMQ。
    仅仅盲目转发所有的奇数给一个消费者，偶数给另一个消费者。
    为了解决这样的问题，我们可以使用basicQos方法，传递参数为prefetchCount= 1。这样告诉RabbitMQ不要在同一时间给一个消费者超过一条消息。
    换句话说，只有在消费者空闲的时候会发送下一条信息。
    调度分发消息的方式，也就是告诉RabbitMQ每次只给消费者处理一条消息， 
# **也就是等待消费者处理完毕并自己对刚刚处理的消息进行确认之后**  才发送下一条消息，防止消费者太过于忙碌，也防止它太过去清闲。


# exchage 交换机类型:
     1. direct ： 如果路由键完全匹配的话,消息才会被投放到相应的队列.
     2. topic  ： 设置模糊的绑定方式,"*"操作符将"."视为分隔符,匹配单个字符;"#"操作符没有分块的概念,它将任意"."均视为关键字的匹配部分,能够匹配多个字符
     3. headers 
     4. fanout ： 当发送一条消息到fanout交换器上时,它会把消息投放到所有附加在此交换器的上的队列.
# RabbitMQ 持久化:     
     消息 持久化：     channel.basicPublish(TOPIC_EXCHANGE_NAME, "item.insert", MessageProperties.PERSISTENT_BASIC, message.getBytes());
     队列 持久化：     channel.queueDeclare(QUEUE1, true, false, false, null);
     交换器 持久化：   channel.exchangeDeclare(TOPIC_EXCHANGE_NAME, "direct",true);
     
#RabbitMQ的五种模式
     1.简单队列(simple-demo1)   
     一个生产者对应一个消费者!!!
     2.work模式(simple-demo2)  
     一个生产者对应多个消费者,但是只能有一个消费者获得消息!!!
     3.发布/订阅模式
     一个消费者将消息首先发送到交换器,交换器绑定多个队列,然后被监听该队列的消费者所接收并消费.
     4.路由模式
     生产者将消息发送到direct交换器,在绑定队列和交换器的时候有一个路由key,生产者发送的消息会指定一个路由key,那么消息只会发送到相应key相同的队列,接着监听该队列的消费者消费信息.
     5.主题模式
     上面的路由模式是根据路由key进行完整的匹配(完全相等才发送消息),这里的通配符模式通俗的来讲就是模糊匹配.
     符号"#"表示匹配一个或多个词,符号"*"表示匹配一个词.
     
     
     