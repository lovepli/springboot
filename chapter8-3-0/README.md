
#rabbitmq 与 kafka 对比

    rabbitmq       
    1.RabbitMQ的消息应当尽可能的小，并且只用来处理实时且要高可靠性的消息。
    2.消费者和生产者的能力尽量对等，否则消息堆积会严重影响RabbitMQ的性能。
    3.集群部署，使用热备，保证消息的可靠性。
    
    kafka
    1.应当有一个非常好的运维监控系统，不单单要监控Kafka本身，还要监控Zookeeper。(kafka强烈的依赖于zookeeper,如果zookeeper挂掉了，那么Kafka也不行了)
    2.对消息顺序不依赖，且不是那么实时的系统。
    3.对消息丢失并不那么敏感的系统。
    4.从 A 到 B 的流传输，无需复杂的路由，最大吞吐量可达每秒 100k 以上。


# RabbitMQ 
    5672  客户端代码 连接端口
    15672 web 页面管理端口 
    
    
#公平转发
    
    目前消息转发机制是平均分配，这样就有可能会出现俩个消费者，奇数的任务很耗时，偶数的任何工作量很小，
    造成的原因就是近当消息到达队列进行转发消息。并不在乎有多少任务消费者并未传递一个应答给RabbitMQ。
    仅仅盲目转发所有的奇数给一个消费者，偶数给另一个消费者。
    为了解决这样的问题，我们可以使用basicQos方法，传递参数为prefetchCount= 1。这样告诉RabbitMQ不要在同一时间给一个消费者超过一条消息。
    换句话说，只有在消费者空闲的时候会发送下一条信息。
    调度分发消息的方式，也就是告诉RabbitMQ每次只给消费者处理一条消息， 
# **也就是等待消费者处理完毕并自己对刚刚处理的消息进行确认之后**  才发送下一条消息，防止消费者太过于忙碌，也防止它太过去清闲。


# exchage 交换机类型:
     1. direct ： 如果路由键完全匹配的话,消息才会被投放到相应的队列.
     2. topic  ： 设置模糊的绑定方式,"*"操作符将"."视为分隔符,匹配单个字符;"#"操作符没有分块的概念,它将任意"."均视为关键字的匹配部分,能够匹配多个字符
     3. headers 
     4. fanout ： 当发送一条消息到fanout交换器上时,它会把消息投放到所有附加在此交换器的上的队列.
# RabbitMQ 持久化:     
     消息 持久化：     channel.basicPublish(TOPIC_EXCHANGE_NAME, "item.insert", MessageProperties.PERSISTENT_BASIC, message.getBytes());
     队列 持久化：     channel.queueDeclare(QUEUE1, true, false, false, null);
     交换器 持久化：   channel.exchangeDeclare(TOPIC_EXCHANGE_NAME, "direct",true);
     
#RabbitMQ的五种模式
     1.简单队列(simple-demo1)   
     一个生产者对应一个消费者!!!
     2.work模式(simple-demo2)  
     一个生产者对应多个消费者,但是只能有一个消费者获得消息!!!
     3.发布/订阅模式
     一个消费者将消息首先发送到交换器,交换器绑定多个队列,然后被监听该队列的消费者所接收并消费.
     4.路由模式
     生产者将消息发送到direct交换器,在绑定队列和交换器的时候有一个路由key,生产者发送的消息会指定一个路由key,那么消息只会发送到相应key相同的队列,接着监听该队列的消费者消费信息.
     5.主题模式
     上面的路由模式是根据路由key进行完整的匹配(完全相等才发送消息),这里的通配符模式通俗的来讲就是模糊匹配.
     符号"#"表示匹配一个或多个词,符号"*"表示匹配一个词.