# 缓存雪崩
          缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。和缓存击穿不同的是，        
          缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。
          
          解决方案：
          
          缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。
          如果缓存数据库是分布式部署，将热点数据均匀分布在不同搞得缓存数据库中。
          设置热点数据永远不过期。



# 缓存击穿

    缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），
    这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力

    缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，
    当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。
    小编在做电商项目的时候，把这货就成为“爆款”。
    其实，大多数情况下这种爆款很难对数据库服务器造成压垮性的压力。达到这个级别的公司没有几家的。
    所以，务实主义的小编，对主打商品都是早早的做好了准备，让缓存永不过期。即便某些商品自己发酵成了爆款，也是直接设为永不过期就好了。
    大道至简，mutex key互斥锁真心用不上。


# 缓存穿透
        缓存穿透，是指查询一个数据库一定不存在的数据。正常的使用缓存流程大致是，数据查询先进行缓存查询，
        如果key不存在或者key已经过期，再对数据库进行查询，并把查询到的对象，放进缓存。如果数据库查询对象为空，则不放进缓存
        
        解决方法：
        想象一下这个情况，如果传入的参数为-1，会是怎么样？这个-1，就是一定不存在的对象。
        就会每次都去查询数据库，而每次查询都是空，每次又都不会进行缓存。
        假如有恶意攻击，就可以利用这个漏洞，对数据库造成压力，甚至压垮数据库。即便是采用UUID，也是很容易找到一个不存在的KEY，进行攻击。
        在工作中，会采用缓存空值的方式，也就是【代码流程】中第5步，如果从数据库查询的对象为空，也放入缓存，只是设定的缓存过期时间较短，比如设置为60秒。

        解决方案：
        1.接口层增加校验，如用户鉴权校验，id做基础校验，id<=0的直接拦截；
        2.从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击
