package com.goat.B.B06.item02;

/**
 * Created by 64274 on 2019/7/15.
 *
 在抽象菜单MenuComponent组件中，我们将一些操作默认抛出UnsupportedOperationException异常，
 如果子类支持该操作就重写实现该操作，如果子类不支持该操作，就不用管它。使用组合模式，打印菜单变得非常容易，
 而且更好的一点是，你现在可以拿任何一个子菜单来打印结果，而不用管它是具体的菜单项还是里面又包含了子菜单。
 如果不用组合模式，很难想象有一种方法能很方便的将所有的菜单打印出来。

 * @ date 2019/7/15---21:05
 */
public class Client {
    public static void main(String[] args) {
        Menu menu = new Menu("所有菜单");

        Menu menu1 = new Menu("子菜单1");
        Menu menu2 = new Menu("子菜单2");
        Menu menu3 = new Menu("子菜单3");

        //给所有菜单添加三个子菜单
        menu.add(menu1);
        menu.add(menu2);
        menu.add(menu3);

        //给第二个菜单添加一个菜单项和一个子菜单
        menu2.add(new MenuItem("子菜单2--菜单项", 10.0));
        Menu menu4 = new Menu("子菜单2--子菜单");
        menu2.add(menu4);
        menu4.add(new MenuItem("子菜单2--子菜单--菜单项", 20.0));

        //打印所有菜单
        menu.print();
    }
}

/**
 菜单例子中，既要管理层次结构，又要执行打印操作，是否破坏了单一职责？

   严格来说，是的。我们可以这么说，组合模式以单一职责换取透明性。
 什么是透明性？通过让组件的接口同时包含一些管理子节点和叶节点的操作，客户就可以将组合和叶节点 一视同仁。
 也就是说一个元素究竟是组合还是叶节点，对客户是透明的。

   现在，我们在 MenuComponent 类中同时具有两种类型的操作． 因为客户有机会对一个元素做一些没有意义的操作（例如试图把菜单添加到菜单项），
 所以我们失去 一些‘安会性”。这是设计上的抉择；我们当然也可以采用另一种方向的设计，将责任区分开来放在不同的接口中。这么一来，设计上就比较安全，
 但我们也因此失去了透明性，客户的代码将必须使用条件语句和 instanceof 操作符处理不同类型的节点。

   所以， 这是一个很典型的折衷案例。尽管我们受到设计原则的指导，但是，我们总是需要观察某原则对我们的设计所造成的影响。
 有时候，我们会故意做一些看似违反原则的事情。然而，在某些例子中，这是观点的问题。
 比方说让管理孩子的操作（例如 add ( ）、 remove( ）、 getchild ( ) ）出现在叶节点中，
 似乎很不恰当，但是换个视角来看，你可以把叶布点视为没有孩子的节点。

 */