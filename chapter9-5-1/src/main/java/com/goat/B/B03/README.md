# 代理模式  的 应运而生
    不使用代理开发的话  代码有两个致命的问题。
    
    1.代码混乱：越来越多的非业务需求(日志和验证等)加入后, 原有的业务方法急剧膨胀. 
    每个方法在处理核心逻辑的同时还必须兼顾其他多个关注点.  比如：每新添加了方法，还得继续写日志和验证
   
    2.代码分散: 以日志需求为例, 只是为了满足这个单一需求, 就不得不在多个模块（方法）里多次重复相同的日志代码. 如果日志需求发生变化, 
    必须修改所有模块. 
    比如：现在此类的方法里都显示方法名，那么每个方法都得一个一个改
    
    因此 动态代理 应运而生 ！ 使用动态代理 可以拿到目标方法 从而 再目标方法执行之前/后  进行前置/后置处理 来增强方法 AOP 的典型应用。

# Java 代理模式实现方式，主要有如下五种方法
    静态代理，工程师编辑代理类代码，实现代理模式；在编译期就生成了代理类。
    
    基于JDK实现动态代理，通过jdk提供的工具方法Proxy.newProxyInstance动态构建全新的代理类(继承Proxy类，并持有InvocationHandler接口引用 )字节码文件并实例化对象返回。
                            (jdk动态代理是由java内部的反射机制来实例化代理对象，并代理的调用委托类方法)
    
    基于CGlib动态代理模式 基于继承被代理类生成代理子类，不用实现接口。只需要被代理类是非final 类即可。(cglib动态代理底层是借助asm字节码技术
    
    基于 Aspectj 实现动态代理（修改目标类的字节，织入代理的字节，在程序编译的时候 插入动态代理的字节码，不会生成全新的Class ）
    
    基于 instrumentation 实现动态代理（修改目标类的字节码、类装载的时候动态拦截去修改，基于javaagent） -javaagent:spring-instrument-4.3.8.RELEASE.jar （类装载的时候 插入动态代理的字节码，不会生成全新的Class ）

# 按照代理的创建时期，代理类可以分为两种： 静态代理 与 动态代理
    静态代理：   需要生产目标代理对象  eg: 由程序员创建代理类或特定工具自动生成源代码再对其编译。在程序运行前代理类的.class文件就已经存在了。
    动态代理： 不需要生产目标代理对象  eg: 在程序运行时运用反射机制动态创建而成。
    
# JDK 动态代理 与 Cglib 动态代理
    JDK 动态代理机制只能代理实现了指定接口的类，若没有实现指定接口的类， 就不能对其实现JDK的动态代理，
    Cglib 是针对类来实现代理的，他的原理是对指定的目标类生成一个子类，并覆盖其中方法实现增强，但因为采用的是继承，所以不能对final修饰的类进行代理。
    
    CGLIB代理和JDK代理最大的区别就是：CGLIB代理的对象不需要实现任何接口，它使用的字节码子类代理方式，但是JDK代理的对象必须实现接口
    
    JDK 动态代理是通过接口中的方法名，在动态生成的代理类中调用业务实现类的同名方法；
    CGlib 动态代理是通过继承业务类，生成的动态代理类是业务类的子类，通过重写业务方法进行代理；
    
    JDK 动态代理    实现 InvocationHandler 代理接口  创建动态代理类
    CGlib 动态代理  实现 MethodInterceptor 代理接口，创建动态代理类
    
    
# Cglib 动态代理

        example01： 静态代理
        example02： 静态代理 
        example03： 静态代理
        example04： 静态代理
        example05： 使用Cglib代码对类做代理的通用写法
        example06： 使用Cglib定义不同的拦截策略
        example07： 静态代理
        example08： JDK动态代理
    
    
    Cglib 要点描述：
    代理类：继承了目标类，则在代理类中通过调用父类方法，即调用到了目标类方法。整个代理过程无需强制持有目标类的实例。
    增强器/拦截器类：实现MethodInterceptor接口的intercept方法，以达成对目标类的代理或者说功能增强（方法参数见下文：增强器/拦截器接口源码）。
    增强器/拦截器映射器：CallbackFilter。通过入参为Method类型，出参为int型增强器/拦截器数组的索引的accept方法，决定代理方法实际对应的是哪一个增强器/拦截器。（见下文：接口实现示例）
    通过Enhancer类实例，可以设置继承的目标类，传入增强器/拦截器实例组（可选），及设置增强器/拦截器映射器（可选），最终调用Enhancer#create()方法创建代理实例。
    对代理类方法的调用，实际是对增强器/拦截器组中的指定1个增强器/拦截器的intercept方法进行调用（如果没有设置增强器/拦截器，则通过super直接调用父类方法，即目标方法。不过目前还没找到能不设置的方法）
    intercept方法，一般通过代理实例上调用代理方法来反射调用到目标方法。
 