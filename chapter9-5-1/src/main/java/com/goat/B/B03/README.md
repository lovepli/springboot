    
# JDK 动态代理 与 Cglib 动态代理
    JDK 动态代理机制只能代理实现了指定接口的类，若没有实现指定接口的类， 就不能对其实现JDK的动态代理，
    Cglib 是针对类来实现代理的，他的原理是对指定的目标类生成一个子类，并覆盖其中方法实现增强，但因为采用的是继承，所以不能对final修饰的类进行代理。
    
    JDK 动态代理是通过接口中的方法名，在动态生成的代理类中调用业务实现类的同名方法；
    CGlib 动态代理是通过继承业务类，生成的动态代理类是业务类的子类，通过重写业务方法进行代理；
    
    JDK 动态代理    实现 InvocationHandler 代理接口  创建动态代理类
    CGlib 动态代理  实现 MethodInterceptor 代理接口，创建动态代理类
    
# 静态代理 与 动态代理
    静态代理：   需要生产目标代理对象
    动态代理： 不需要生产目标代理对象
    
    
# Cglib 动态代理

        example05： 使用Cglib代码对类做代理的通用写法
        example06： 使用Cglib定义不同的拦截策略
        example07： 静态代理
        example08： JDK 动态代理
    
    
    Cglib 要点描述：
    代理类：继承了目标类，则在代理类中通过调用父类方法，即调用到了目标类方法。整个代理过程无需强制持有目标类的实例。
    增强器/拦截器类：实现MethodInterceptor接口的intercept方法，以达成对目标类的代理或者说功能增强（方法参数见下文：增强器/拦截器接口源码）。
    增强器/拦截器映射器：CallbackFilter。通过入参为Method类型，出参为int型增强器/拦截器数组的索引的accept方法，决定代理方法实际对应的是哪一个增强器/拦截器。（见下文：接口实现示例）
    通过Enhancer类实例，可以设置继承的目标类，传入增强器/拦截器实例组（可选），及设置增强器/拦截器映射器（可选），最终调用Enhancer#create()方法创建代理实例。
    对代理类方法的调用，实际是对增强器/拦截器组中的指定1个增强器/拦截器的intercept方法进行调用（如果没有设置增强器/拦截器，则通过super直接调用父类方法，即目标方法。不过目前还没找到能不设置的方法）
    intercept方法，一般通过代理实例上调用代理方法来反射调用到目标方法。
 