# volatile：    
     volatile： 是java虚拟机提供的轻量级的同步机制(synchronized)
      三大特性：
      1.保证可见性 ： 一个线程修改了主内存中的变量 ，那么其他已经读取过该变量的线程 马上获得通知，这种特性叫做可见性
      2.不保证原子性 ： 
      3.禁止指令重排 ：
      
# JMM  java 内存模型
    JMM 是一种抽象概念，并不真实存在
    JMM 关于同步的规定：
        1. 线程解锁前，必须把共享变量的值刷新回主内存
        2. 线程加锁前，必须读取主内存的最新值到自己的工作区
        3. 加锁/解锁是同一把锁
        
        一个AAA线程修改了共享变量X的值  但还未回写到主内存时，另一个BBB线程又对主内存中的同一个共享变量X进行操作
        但此时A线程工作内存中的共享变量X 对线程BBB来说 并不可见
        
        可见性就是指当一个线程修改了线程共享变量的值，其它线程能够立即得知这个修改。
        无论是普通变量还是volatile变量都是如此，普通变量与volatile变量的区别是volatile的特殊规则保证了新值能立即同步到主内存，
        以及每使用前立即从内存刷新。
        因此 我们可以说volatile保证了线程操作时变量的可见性，而普通变量则不能保证这一点。
        
![Image text](https://github.com/yangfancoming/springboot/blob/master/chapter9-0-1/src/main/img/cpu高速缓存.jpg)
# CPU 高速缓存一致性 问题
    计算机在运行程序时，每条指令都是在CPU中执行的，在执行过程中势必会涉及到数据的读写。
    我们知道程序运行的数据是存储在主存中，这时就会有一个问题，读写主存中的数据没有CPU中执行指令的速度快，
    如果任何的交互都需要与主存打交道则会大大影响效率，所以就有了CPU高速缓存。CPU高速缓存为某个CPU独有，只与在该CPU运行的线程有关。
    有了CPU高速缓存虽然解决了效率问题，但是它会带来一个新的问题：数据一致性。
    在程序运行中，会将运行所需要的数据复制一份到CPU高速缓存中，在进行运算时CPU不再也主存打交道，
    而是直接从高速缓存中读写数据，只有当运行结束后才会将数据刷新到主存中。
    见图：cpu高速缓存.jpg

    如何解决缓存一致性：
    缓存一致性协议（MESI协议）它确保每个缓存中使用的共享变量的副本是一致的。
    其核心思想如下：当某个CPU在写数据时，如果发现操作的变量是共享变量(volatile)，则会通知其他CPU告知该变量的缓存行是无效的，
    因此其他CPU在读取该变量时（对应下面三步中的步骤1），发现其无效会重新从主存中加载数据。
    
    举例：
    i++ 就不是原子性操作，因为他需要三步： 分三步 (i为volatile变量)
        1.线程读取i的值
        2.将i加1
        3.写入i值
        
        A线程刷新值后  B线程 执行在1步骤时 会刷新主存 
        A线程刷新值后  B线程 执行在2或3 步骤时   是不会强制刷新主存的
        
        这也就说明了  volatile  不保证原子性  即 线程不安全

