
# 目录
    A01 类 加载、连接、初始化
    A02 类加载器
    A03 反射方式/常见反射方式  通过发射查看类信息
    A04 使用反射生成并操作对象
    A05 使用反射生成JDK动态代理
    
    
    C02 TypeVariable  
    C03 ParameterizedType 参数化类型 
    
# 为什么需要反射？  反射应运而生！
    反射是什么呢？当我们的程序在运行时，需要动态的加载一些类这些类可能之前用不到所以不用加载到jvm，
    而是在运行时根据需要才加载，这样的好处对于服务器来说不言而喻，
    举个例子我们的项目底层有时是用mysql，有时用oracle，需要动态地根据实际情况加载驱动类，
    这个时候反射就有用了，假设 com.java.dbtest.myqlConnection，com.java.dbtest.oracleConnection这两个类我们要用，
    这时候我们的程序就写得比较动态化，通过Class tc = Class.forName("com.java.dbtest.TestConnection");
    通过类的全类名让jvm在服务器中找到并加载这个类，而如果是oracle则传入的参数就变成另一个了。
    这时候就可以看到反射的好处了，这个动态性就体现出java的特性了！
    举多个例子，大家如果接触过spring，会发现当你配置各种各样的bean时，是以配置文件的形式配置的，
    你需要用到哪些bean就配哪些，spring容器就会根据你的需求去动态加载，你的程序就能健壮地运行。
    
    java的反射机制就是增加程序的灵活性，避免将程序写死到代码里， 例如： 实例化一个 person()对象，
    不使用反射， new person(); 如果想变成 实例化 其他类， 那么必须修改源代码，并重新编译。
    使用反射： class.forName("person").newInstance()； 而且这个类描述可以写到配置文件中，
    如 **.xml, 这样如果想实例化其他类，只要修改配置文件的"类描述"就可以了，不需要重新修改代码并编译
    
    
    反射的优点：
        1. 可以在程序运行的过程中，操作对象。 eg： IDEA 的成员函数智能提示
        2. 解耦，提高程序的可扩展性。